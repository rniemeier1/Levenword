# Levenword
Levenword is the application I am designing for my Software Development capstone project. This repository is devoted to the User Interface. To see the Service Layer respository, please visit [Levenword_ServiceLayers](https://github.com/rniemeier1/Levenword_ServiceLayers).

## Problem Description

Word games are popular and new ones seem to catch the attention of public eye pretty consistently. Recent popular word games, such as Wordle and Words with Friends are more recent iterations, but word searches and spelling bees have been around longer than the Internet. Since the innovation of the internet, new ways to play games have been cropping up and now users can pretend to be a farmer, match jewels together, and even play virtual tag. 
  
My project combines the ability to manipulate the game field as found in games like Bejeweled with the desire to locate words as found in word searches. Users will be able to share their scores with friends and see their score history. Using the Levenshtein Distance allows for the experience to be enjoyable without making it too difficult for users. 
  
 The goal for this project is user entertainment. It provides the ability for people to compete with one another for better scores, while making sure that users are still able to enjoy the game. I anticipate that users would be able to solve the game in a 15 minute timespan, so they could do it over their lunch break, coffee, or any other short break during the day. 
  
## Minimum Viable Product

Users will visit the website, where they are initially prompted to create a username. I haven’t quite decided whether I want to just store the user data in browser cookies or have them create a full-fledged account system. Many similar games just operate on browser cookies. After creating a username, the user will then be shown the game of the day. Once the game is completed, they will be offered the ability to share their score and rate how hard the game was that day, as well as the current best score for the day. Users will also be able to view their past scores with the date completed and the word pool from that day, and possibly be able to replay the game from that day. 
  
Minimally, the game needs to be functional. Sharing, accounts, and historical data are all features that can be added later. The application also needs to be cross platform, so users can play on their computers and mobile devices. 
  
Architecturally, I plan to use an SQL database. One table will store a dictionary, with fields for whether that words has been selected before and any other relevant information. Another table will hold puzzle data, including words, top score, and average rating. Other tables, such as user data and historical game completion data for each user, will also exist. I’m currently planning to create the application in .Net MVC, since I’m familiar with the framework, and hosting on AWS, since Heroku doesn’t provide .Net support. 
  
The application will create one game each day, starting with a randomly selected word from a dictionary. The word must be at least four letters in length. It will then go through all of the other words in the dictionary and perform a Levenshtein Distance calculation between the two words. Then, it will find the correct minimum distance necessary for there to be between 8 and 12 words available for the daily game. Once a word pool has been found, the game board will be created by finding the percentage that each letter appears in the word pool. The game board will fill by maintaining a similar percentage of letters of the words remaining that haven’t been found. Letters that have a 0% incidence will never appear, and won’t be options for user manipulation. These parameters will be created during the day prior to the puzzle being live to allow for any necessary processing time to create the puzzle. At 12:01 am EST, the puzzle will go live and replace the puzzle from the previous day. 

Users will open the game, and be presented with a field of letters randomly generated from the word pool letter percentages. Users will then be able to insert, delete, and replace letters on the board to create the words in the list. When inserting, users will select a letter and be asked whether they want to shift right, left, up, or down (as relevant). Letters that are pushed off the board will be removed. Deleting is the inverse of insertion, with letters being shifted in with a random letter being added to fill the side of the board. Replacing a letter will just be a prompt with the letter they want to replace. When a user believes they have found a word, they will have to choose a “select world” option, and then click each letter of the word. Diagonals will be allowed, and words won’t need to be in a straight line. 

The game is scored similar to golf. The goal score (“par”) will be the number of words times the distance for the day, plus one per word (subject to change based once the game is in testing). A lower score means better performance. Users will be shown their score, allowed to rate the day’s game, and be shown a share score button on a pop-up modal. 
